---
title: Merging vs. Rebasing
author: Martín Macías
date: '2018-03-01'
slug: merging-vs-rebasing
categories:
  - git
  - Github
tags:
  - git
  - Github
---



<div id="vision-conceptual" class="section level2">
<h2>Visión conceptual</h2>
<p>Lo primero que debe entenderse sobre <code>git rebase</code> es que resuelve el mismo problema que <code>git merge</code>. Ambos comandos están diseñados para integrar cambios de un branch a otro branch; solo lo hacen de maneras muy diferentes.</p>
<p>Considere lo que sucede cuando comienza a trabajar en una nueva característica en un branch dedicado para tal fin, luego otro miembro del equipo actualiza el branch <code>master</code> con nuevos commits. Esto da como resultado una historia bifurcada, que debería ser familiar para cualquiera que haya usado Git como herramienta de colaboración.</p>
<p><img src="/Users/martin/Github/martin/images/01.svg" width="100%" /></p>
<p>Ahora, digamos que los nuevos commits en el branch <code>master</code> son relevantes para la función en la que se está trabajando en el otro branch. Para incorporar los nuevos commits en su branch de <code>características</code>, tiene dos opciones: <code>merge</code> o <code>rebase</code>.</p>
<div id="opcion-merge" class="section level3">
<h3>Opción <code>merge</code></h3>
<p>La opción más fácil es fusionar el branch <code>master</code> en el branch <code>características</code> usando:</p>
<pre class="bash"><code>git checkout feature
git merge master</code></pre>
<p>O condensarlo en una línea:</p>
<pre class="bash"><code>git merge master feature</code></pre>
<p>Esto crea un nueva “merge commit” en el branch <code>características</code> que vincula las historias de ambos branches, dándole una estructura de bifurcación que se ve así:</p>
<p><img src="/Users/martin/Github/martin/images/02.svg" width="100%" /></p>
<p>La fusión es agradable porque es una operación no destructiva. Las ramas existentes no se modifican de ninguna manera. Esto evita todas las trampas potenciales del rebasamiento (discutidas a continuación).</p>
<p>Por otro lado, esto también significa que la rama <code>características</code> tendrá un commit de fusión extraño cada vez que necesite incorporar cambios ascendentes. Si el <code>master</code> es muy activo, esto puede contaminar un poco la historia de su rama <code>características</code>. Si bien es posible mitigar este problema con las opciones avanzadas de <code>git log</code>, puede dificultar que otros desarrolladores comprendan el historial del proyecto.</p>
</div>
<div id="opcion-rebase" class="section level3">
<h3>Opción <code>rebase</code></h3>
<p>Como alternativa a la fusión, puede volver a establecer la base de la rama <code>características</code> en la rama <code>master</code> mediante los siguientes comandos:</p>
<pre class="bash"><code>git checkout feature
git rebase master</code></pre>
<p>Esto mueve toda la rama <code>características</code> para que comience al inicio de la rama <code>master</code>, incorporando efectivamente todos los nuevos commits en el <code>master</code>. Pero, en lugar de usar un merge commit, rebasing vuelve a escribir el historial del proyecto creando commits nuevos para cada commit en la rama <code>master</code>.</p>
<p><img src="/Users/martin/Github/martin/images/03.svg" width="100%" /></p>
<p>El mayor beneficio de rebase es que obtiene un historial de proyectos mucho más limpio. Primero, elimina los innecesarios merge commits requeridos por <code>git merge</code>. En segundo lugar, como puede ver en el diagrama anterior, rebase también da como resultado un historial de proyecto perfectamente lineal: puede seguir la punta de <code>característica</code> hasta el comienzo del proyecto sin ninguna bifurcación. Esto facilita navegar por su proyecto con comandos como <code>git log</code>, <code>git bisect</code> y `gitk.</p>
<p>Pero, hay dos compensaciones para este prístino historial de commits: seguridad y trazabilidad. Si no sigue <a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing">la regla de oro de rebase</a>, volver a escribir el historial del proyecto puede ser potencialmente catastrófico para su flujo de trabajo de colaboración. Y, lo que es menos importante, el rebasamiento pierde el contexto proporcionado por una merge commit –no se puede ver cuando se incorporaron los cambios de flujo ascendente en `característica.</p>
</div>
<div id="rebase-interactivo" class="section level3">
<h3>Rebase interactivo</h3>
<p>El rebasamiento interactivo le da la oportunidad de alterar los commits a medida que se mueven al nuevo branch. Esto es incluso más poderoso que un rebase automático, ya que ofrece un control completo sobre el historial de commits del branch. Normalmente, esto se usa para limpiar un historial desordenado antes de fusionar el branch <code>características</code> en <code>master</code>.</p>
<p>Para comenzar una sesión de rebase interactiva, adhiera la opción <code>i</code> al comando <code>git rebase</code>:</p>
<pre class="bash"><code>git checkout feature
git rebase -i master</code></pre>
<p>Esto abrirá un editor de texto que enumera todos los commits que están a punto de ser movidas:</p>
<pre class="bash"><code>pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3</code></pre>
<p>Esta lista define exactamente cómo se verá el branch después de que se realice el rebase. Al cambiar el comando de selección y/o reordenar las entradas, puede hacer que el historial del branch tenga el aspecto que desee. Por ejemplo, si el segundo commit corrige un pequeño problema en el primer commit, puede condensarlos en un solo commit con el comando <code>fixup</code>:</p>
<pre class="bash"><code>pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3`</code></pre>
<p>Cuando guarda y cierra el archivo, Git realizará el rebase de acuerdo con sus instrucciones, lo que da como resultado el historial del proyecto que se ve así:</p>
<p><img src="/Users/martin/Github/martin/images/04.svg" width="100%" /></p>
<p>La eliminación de commits insignificantes como este hace que la historia de <code>característica</code> sea mucho más fácil de entender. Esto es algo que <code>git merge</code> simplemente no puede hacer.</p>
</div>
</div>
